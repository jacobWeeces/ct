#!/usr/bin/env bash
set -euo pipefail

CT_DIR="${HOME}/.ct"
DTACH_BIN="/opt/homebrew/bin/dtach"
DEFAULT_SHELL="${SHELL:-/bin/zsh}"

# Filter mode: strip terminal DA (Device Attributes) responses that cause display issues
# with tools like Claude Code when connecting through mobile terminals like Termius
CT_FILTER_DA="${CT_FILTER_DA:-0}"

# Check if a process is alive and not a zombie
is_process_alive() {
    local pid="$1"
    if [[ -z "$pid" ]]; then
        return 1
    fi
    # Check process exists and is not zombie (state Z)
    if ps -p "$pid" -o state= 2>/dev/null | grep -qv "Z"; then
        return 0
    fi
    return 1
}

# Check if process is healthy (not spinning at 100% CPU for too long)
is_process_healthy() {
    local pid="$1"
    if ! is_process_alive "$pid"; then
        return 1
    fi
    # Get CPU percentage - if over 90% it's likely a zombie spinning
    local cpu
    cpu=$(ps -p "$pid" -o %cpu= 2>/dev/null | tr -d ' ' | cut -d. -f1)
    if [[ -n "$cpu" && "$cpu" -gt 90 ]]; then
        # Check if it's been running a long time (over 10 min of CPU time)
        local cputime
        cputime=$(ps -p "$pid" -o cputime= 2>/dev/null | tr -d ' ')
        if [[ -n "$cputime" ]]; then
            # Parse MM:SS or HH:MM:SS format
            local minutes
            minutes=$(echo "$cputime" | awk -F: '{if(NF==2) print $1; else print $1*60+$2}')
            if [[ "$minutes" -gt 10 ]]; then
                return 1  # Unhealthy - spinning too long
            fi
        fi
    fi
    return 0
}

# Get status of a session: ALIVE, DEAD, ZOMBIE, or MISSING
get_session_status() {
    local name="$1"
    local sock_file="${CT_DIR}/${name}.sock"
    local pid_file="${CT_DIR}/${name}.pid"

    if [[ ! -e "$sock_file" && ! -e "$pid_file" ]]; then
        echo "MISSING"
        return
    fi

    if [[ ! -e "$pid_file" ]]; then
        echo "DEAD"  # Socket exists but no PID file
        return
    fi

    local pid
    pid=$(cat "$pid_file" 2>/dev/null)

    if ! is_process_alive "$pid"; then
        echo "DEAD"
        return
    fi

    if ! is_process_healthy "$pid"; then
        echo "ZOMBIE"
        return
    fi

    echo "ALIVE"
}

# Clean up a session (kill process, remove files)
cleanup_session() {
    local name="$1"
    local sock_file="${CT_DIR}/${name}.sock"
    local pid_file="${CT_DIR}/${name}.pid"

    if [[ -e "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && is_process_alive "$pid"; then
            # Kill the process tree
            pkill -TERM -P "$pid" 2>/dev/null || true
            kill -TERM "$pid" 2>/dev/null || true
            sleep 0.2
            # Force kill if still alive
            if is_process_alive "$pid"; then
                pkill -KILL -P "$pid" 2>/dev/null || true
                kill -KILL "$pid" 2>/dev/null || true
            fi
        fi
        rm -f "$pid_file"
    fi

    rm -f "$sock_file"
}

# Clean up all ct-managed sessions ONLY (never touches ~/.dtach/)
cleanup_all() {
    echo "Cleaning up all ct sessions in ${CT_DIR}..."
    echo "(Your ~/.dtach/ sessions are untouched)"
    echo ""

    # ONLY clean up sessions WE manage (in ~/.ct/)
    local cleaned=0
    for pid_file in "${CT_DIR}"/*.pid; do
        [[ -e "$pid_file" ]] || continue
        local name
        name=$(basename "$pid_file" .pid)
        echo "  Cleaning: $name"
        cleanup_session "$name"
        ((cleaned++))
    done

    # Only kill dtach processes pointing to OUR directory, not ~/.dtach/
    pkill -9 -f "dtach.*\.ct/" 2>/dev/null || true

    # Clean up stale socket files in OUR directory only
    rm -f "${CT_DIR}"/*.sock 2>/dev/null || true

    if [[ $cleaned -eq 0 ]]; then
        echo "  (no ct sessions to clean)"
    fi
    echo ""
    echo "Done. Your ~/.dtach/ sessions were NOT touched."
}

# List all sessions with their status
list_sessions() {
    echo "Sessions in ${CT_DIR}:"
    echo ""

    local found=0
    for sock_file in "${CT_DIR}"/*.sock; do
        [[ -e "$sock_file" ]] || continue
        found=1
        local name
        name=$(basename "$sock_file" .sock)
        local status
        status=$(get_session_status "$name")
        local pid=""
        if [[ -e "${CT_DIR}/${name}.pid" ]]; then
            pid=$(cat "${CT_DIR}/${name}.pid" 2>/dev/null)
        fi

        case "$status" in
            ALIVE)  printf "  %-20s %s (pid: %s)\n" "$name" "✓ ALIVE" "$pid" ;;
            DEAD)   printf "  %-20s %s\n" "$name" "✗ DEAD (needs cleanup)" ;;
            ZOMBIE) printf "  %-20s %s (pid: %s)\n" "$name" "⚠ ZOMBIE (will auto-clean)" "$pid" ;;
        esac
    done

    # Also check for PID files without sockets
    for pid_file in "${CT_DIR}"/*.pid; do
        [[ -e "$pid_file" ]] || continue
        local name
        name=$(basename "$pid_file" .pid)
        [[ -e "${CT_DIR}/${name}.sock" ]] && continue  # Already handled
        found=1
        printf "  %-20s %s\n" "$name" "✗ ORPHAN (no socket)"
    done

    if [[ $found -eq 0 ]]; then
        echo "  (no sessions)"
    fi
    echo ""
}

# Setup signal handlers for clean detachment
setup_signal_handlers() {
    local name="$1"

    # On SIGHUP (terminal closed), just exit cleanly
    # The dtach master process keeps running
    trap 'exit 0' HUP

    # On SIGTERM, exit cleanly
    trap 'exit 0' TERM
}

# Attach with DA response filtering (for Claude Code compatibility)
# Uses a wrapper script to filter ESC[?6c sequences from the session
#
# The approach: instead of complex bidirectional filtering at the attach level,
# we inject a filter into the shell session itself. This is more reliable for
# interactive terminal use.
attach_with_filter() {
    local sock_file="$1"

    # Method 1: Use stty to try to prevent echo issues
    # Configure terminal to use raw mode with specific settings
    stty -echo -icanon 2>/dev/null || true

    # Send a reset sequence to the session to clear any accumulated garbage
    printf '\033c' | "$DTACH_BIN" -p "$sock_file" 2>/dev/null || true
    sleep 0.1

    # Attach normally - the reset should help with corruption
    exec "$DTACH_BIN" -a "$sock_file" -r winch
}

# Send terminal reset to a session (helps recover from escape sequence corruption)
reset_session() {
    local name="$1"
    local sock_file="${CT_DIR}/${name}.sock"

    if [[ ! -e "$sock_file" ]]; then
        echo "Session '$name' not found."
        return 1
    fi

    echo "Sending terminal reset to '$name'..."
    # ESC c = full reset, ESC [ ! p = soft reset
    printf '\033c\033[!p' | "$DTACH_BIN" -p "$sock_file" 2>/dev/null || true
    echo "Reset sent. Try reconnecting with: ct $name"
}

# Start or attach to a session
# $1 = session name, $2 = use_filter (optional, "filter" to enable)
start_session() {
    local name="$1"
    local use_filter="${2:-}"
    local sock_file="${CT_DIR}/${name}.sock"
    local pid_file="${CT_DIR}/${name}.pid"

    # Check if filtering is enabled via environment or argument
    if [[ "$CT_FILTER_DA" == "1" ]] || [[ "$use_filter" == "filter" ]]; then
        use_filter="filter"
    fi

    # Check current status
    local status
    status=$(get_session_status "$name")

    # Setup handlers before attaching
    setup_signal_handlers "$name"

    case "$status" in
        ZOMBIE|DEAD)
            echo "Cleaning up stale session '$name'..."
            cleanup_session "$name"
            status="MISSING"
            ;;
    esac

    if [[ "$status" == "ALIVE" ]]; then
        if [[ "$use_filter" == "filter" ]]; then
            echo "Attaching to existing session '$name' (with escape sequence filtering)..."
        else
            echo "Attaching to existing session '$name'..."
        fi
        # Send current terminal size to session before attaching
        if [[ -t 0 ]]; then
            local rows cols
            read rows cols < <(stty size 2>/dev/null)
            if [[ -n "$rows" && -n "$cols" ]]; then
                printf 'stty rows %d cols %d 2>/dev/null; kill -WINCH $$ 2>/dev/null\n' "$rows" "$cols" \
                    | "$DTACH_BIN" -p "$sock_file" 2>/dev/null || true
                sleep 0.1
            fi
        fi
        if [[ "$use_filter" == "filter" ]]; then
            attach_with_filter "$sock_file"
        else
            exec "$DTACH_BIN" -a "$sock_file" -r winch
        fi
    else
        echo "Creating new session '$name'..."
        # Start dtach and capture its PID
        # Use -l for login shell (starts in $HOME, sources .zprofile)
        "$DTACH_BIN" -n "$sock_file" -r winch "$DEFAULT_SHELL" -l

        # Find the dtach master process and save PID
        sleep 0.3
        local pid
        pid=$(pgrep -f "dtach -n ${sock_file}" | head -1)
        if [[ -n "$pid" ]]; then
            echo "$pid" > "$pid_file"
        fi

        # Now attach
        if [[ "$use_filter" == "filter" ]]; then
            echo "(Filtering enabled for Claude Code compatibility)"
            attach_with_filter "$sock_file"
        else
            exec "$DTACH_BIN" -a "$sock_file" -r winch
        fi
    fi
}

usage() {
    cat <<EOF
ct - ConnectTerm: Reliable terminal session manager

Usage:
    ct <session>            Attach or create session
    ct -f <session>         Attach with terminal reset (for Claude Code)
    ct -r <session>         Send reset to session (fixes corruption without detaching)
    ct -l, --list           List all sessions with status
    ct -k, --kill <name>    Kill specific session
    ct -x, --killall        Kill all sessions and zombies
    ct -h, --help           Show this help

Options:
    -f, --filter            Send terminal reset before attaching. Helps with escape
                            sequence issues ([?6c) when using Claude Code via Termius.
    -r, --reset             Send terminal reset to a running session. Use when the
                            display is corrupted but you don't want to detach.

Claude Code Compatibility:
    When using Claude Code through Termius, you may see [?6c characters or display
    corruption. This is caused by Device Attributes responses from terminal capability
    queries. To mitigate:

    1. Use: ct -f <session>     # Sends reset before attaching
    2. Or:  ct -r <session>     # Reset without re-attaching (run from another terminal)
    3. Or:  Press Ctrl+L        # Redraw screen inside session
    4. Or:  Type 'reset'        # Full terminal reset inside session

Examples:
    ct work                 Start or attach to 'work' session
    ct -f work              Attach with reset (recommended for Claude Code)
    ct -r work              Send reset to fix corruption
    ct -l                   Show all sessions
    ct -k work              Kill 'work' session

Environment:
    CT_FILTER_DA=1          Always send reset before attaching (same as -f flag)
EOF
}

# Ensure CT_DIR exists
mkdir -p "$CT_DIR"

# Main entry point (to be expanded)
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 1
    fi

    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -x|--killall)
            cleanup_all
            exit 0
            ;;
        -l|--list)
            list_sessions
            exit 0
            ;;
        -k|--kill)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --kill requires a session name"
                exit 1
            fi
            cleanup_session "$2"
            echo "Session '$2' killed."
            exit 0
            ;;
        -f|--filter)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --filter requires a session name"
                echo "Usage: ct -f <session>"
                exit 1
            fi
            start_session "$2" "filter"
            ;;
        -r|--reset)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --reset requires a session name"
                echo "Usage: ct -r <session>"
                exit 1
            fi
            reset_session "$2"
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            start_session "$1"
            ;;
    esac
}

# Allow sourcing for tests
if [[ "${1:-}" == "--source-only" ]]; then
    return 0 2>/dev/null || exit 0
fi

main "$@"
