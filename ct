#!/usr/bin/env bash
set -euo pipefail

CT_DIR="${HOME}/.ct"
DTACH_BIN="/opt/homebrew/bin/dtach"
DEFAULT_SHELL="${SHELL:-/bin/zsh}"

# Check if a process is alive and not a zombie
is_process_alive() {
    local pid="$1"
    if [[ -z "$pid" ]]; then
        return 1
    fi
    # Check process exists and is not zombie (state Z)
    if ps -p "$pid" -o state= 2>/dev/null | grep -qv "Z"; then
        return 0
    fi
    return 1
}

# Check if process is healthy (not spinning at 100% CPU for too long)
is_process_healthy() {
    local pid="$1"
    if ! is_process_alive "$pid"; then
        return 1
    fi
    # Get CPU percentage - if over 90% it's likely a zombie spinning
    local cpu
    cpu=$(ps -p "$pid" -o %cpu= 2>/dev/null | tr -d ' ' | cut -d. -f1)
    if [[ -n "$cpu" && "$cpu" -gt 90 ]]; then
        # Check if it's been running a long time (over 10 min of CPU time)
        local cputime
        cputime=$(ps -p "$pid" -o cputime= 2>/dev/null | tr -d ' ')
        if [[ -n "$cputime" ]]; then
            # Parse MM:SS or HH:MM:SS format
            local minutes
            minutes=$(echo "$cputime" | awk -F: '{if(NF==2) print $1; else print $1*60+$2}')
            if [[ "$minutes" -gt 10 ]]; then
                return 1  # Unhealthy - spinning too long
            fi
        fi
    fi
    return 0
}

# Get status of a session: ALIVE, DEAD, ZOMBIE, or MISSING
get_session_status() {
    local name="$1"
    local sock_file="${CT_DIR}/${name}.sock"
    local pid_file="${CT_DIR}/${name}.pid"

    if [[ ! -e "$sock_file" && ! -e "$pid_file" ]]; then
        echo "MISSING"
        return
    fi

    if [[ ! -e "$pid_file" ]]; then
        echo "DEAD"  # Socket exists but no PID file
        return
    fi

    local pid
    pid=$(cat "$pid_file" 2>/dev/null)

    if ! is_process_alive "$pid"; then
        echo "DEAD"
        return
    fi

    if ! is_process_healthy "$pid"; then
        echo "ZOMBIE"
        return
    fi

    echo "ALIVE"
}

# Clean up a session (kill process, remove files)
cleanup_session() {
    local name="$1"
    local sock_file="${CT_DIR}/${name}.sock"
    local pid_file="${CT_DIR}/${name}.pid"

    if [[ -e "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && is_process_alive "$pid"; then
            # Kill the process tree
            pkill -TERM -P "$pid" 2>/dev/null || true
            kill -TERM "$pid" 2>/dev/null || true
            sleep 0.2
            # Force kill if still alive
            if is_process_alive "$pid"; then
                pkill -KILL -P "$pid" 2>/dev/null || true
                kill -KILL "$pid" 2>/dev/null || true
            fi
        fi
        rm -f "$pid_file"
    fi

    rm -f "$sock_file"
}

# Clean up all ct-managed sessions ONLY (never touches ~/.dtach/)
cleanup_all() {
    echo "Cleaning up all ct sessions in ${CT_DIR}..."
    echo "(Your ~/.dtach/ sessions are untouched)"
    echo ""

    # ONLY clean up sessions WE manage (in ~/.ct/)
    local cleaned=0
    for pid_file in "${CT_DIR}"/*.pid; do
        [[ -e "$pid_file" ]] || continue
        local name
        name=$(basename "$pid_file" .pid)
        echo "  Cleaning: $name"
        cleanup_session "$name"
        ((cleaned++))
    done

    # Only kill dtach processes pointing to OUR directory, not ~/.dtach/
    pkill -9 -f "dtach.*\.ct/" 2>/dev/null || true

    # Clean up stale socket files in OUR directory only
    rm -f "${CT_DIR}"/*.sock 2>/dev/null || true

    if [[ $cleaned -eq 0 ]]; then
        echo "  (no ct sessions to clean)"
    fi
    echo ""
    echo "Done. Your ~/.dtach/ sessions were NOT touched."
}

# List all sessions with their status
list_sessions() {
    echo "Sessions in ${CT_DIR}:"
    echo ""

    local found=0
    for sock_file in "${CT_DIR}"/*.sock; do
        [[ -e "$sock_file" ]] || continue
        found=1
        local name
        name=$(basename "$sock_file" .sock)
        local status
        status=$(get_session_status "$name")
        local pid=""
        if [[ -e "${CT_DIR}/${name}.pid" ]]; then
            pid=$(cat "${CT_DIR}/${name}.pid" 2>/dev/null)
        fi

        case "$status" in
            ALIVE)  printf "  %-20s %s (pid: %s)\n" "$name" "✓ ALIVE" "$pid" ;;
            DEAD)   printf "  %-20s %s\n" "$name" "✗ DEAD (needs cleanup)" ;;
            ZOMBIE) printf "  %-20s %s (pid: %s)\n" "$name" "⚠ ZOMBIE (will auto-clean)" "$pid" ;;
        esac
    done

    # Also check for PID files without sockets
    for pid_file in "${CT_DIR}"/*.pid; do
        [[ -e "$pid_file" ]] || continue
        local name
        name=$(basename "$pid_file" .pid)
        [[ -e "${CT_DIR}/${name}.sock" ]] && continue  # Already handled
        found=1
        printf "  %-20s %s\n" "$name" "✗ ORPHAN (no socket)"
    done

    if [[ $found -eq 0 ]]; then
        echo "  (no sessions)"
    fi
    echo ""
}

# Start or attach to a session
start_session() {
    local name="$1"
    local sock_file="${CT_DIR}/${name}.sock"
    local pid_file="${CT_DIR}/${name}.pid"

    # Check current status
    local status
    status=$(get_session_status "$name")

    case "$status" in
        ZOMBIE|DEAD)
            echo "Cleaning up stale session '$name'..."
            cleanup_session "$name"
            status="MISSING"
            ;;
    esac

    if [[ "$status" == "ALIVE" ]]; then
        echo "Attaching to existing session '$name'..."
        exec "$DTACH_BIN" -a "$sock_file" -r winch
    else
        echo "Creating new session '$name'..."
        # Start dtach and capture its PID
        "$DTACH_BIN" -n "$sock_file" -r winch "$DEFAULT_SHELL"

        # Find the dtach master process and save PID
        sleep 0.3
        local pid
        pid=$(pgrep -f "dtach -n ${sock_file}" | head -1)
        if [[ -n "$pid" ]]; then
            echo "$pid" > "$pid_file"
        fi

        # Now attach
        exec "$DTACH_BIN" -a "$sock_file" -r winch
    fi
}

usage() {
    cat <<EOF
ct - ConnectTerm: Reliable terminal session manager

Usage:
    ct <session>            Attach or create session
    ct -l, --list           List all sessions with status
    ct -k, --kill <name>    Kill specific session
    ct -x, --killall        Kill all sessions and zombies
    ct -h, --help           Show this help

Examples:
    ct work                 Start or attach to 'work' session
    ct -l                   Show all sessions
    ct -k work              Kill 'work' session
EOF
}

# Ensure CT_DIR exists
mkdir -p "$CT_DIR"

# Main entry point (to be expanded)
main() {
    if [[ $# -eq 0 ]]; then
        usage
        exit 1
    fi

    case "$1" in
        -h|--help)
            usage
            exit 0
            ;;
        -x|--killall)
            cleanup_all
            exit 0
            ;;
        -l|--list)
            list_sessions
            exit 0
            ;;
        -k|--kill)
            if [[ -z "${2:-}" ]]; then
                echo "Error: --kill requires a session name"
                exit 1
            fi
            cleanup_session "$2"
            echo "Session '$2' killed."
            exit 0
            ;;
        -*)
            echo "Unknown option: $1"
            usage
            exit 1
            ;;
        *)
            start_session "$1"
            ;;
    esac
}

# Allow sourcing for tests
if [[ "${1:-}" == "--source-only" ]]; then
    return 0 2>/dev/null || exit 0
fi

main "$@"
